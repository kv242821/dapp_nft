import{l as c,_ as d,a as I,c as U,m as o,d as i,h as y,W as k,i as q,w as z,n as K}from"./index-20076c51.js";import{W as Y,U as L,S as O}from"./errors-4bdf81d2.browser.esm-c6ed388f.js";const j="eip155",x="wagmi.requestedChains",N="wallet_addEthereumChain",S="last-used-chain-id";var n=new WeakMap,v=new WeakMap,u=new WeakMap,P=new WeakSet,H=new WeakSet,E=new WeakSet,M=new WeakSet,g=new WeakSet,A=new WeakSet,D=new WeakSet,W=new WeakSet;class Z extends Y{constructor(s){super({...s,options:{isNewChainsStale:!0,...s.options}}),c(this,W),c(this,D),c(this,A),c(this,g),c(this,M),c(this,E),c(this,H),c(this,P),d(this,"id",z.walletConnect),d(this,"name","WalletConnect"),d(this,"ready",!0),I(this,n,{writable:!0,value:void 0}),I(this,v,{writable:!0,value:void 0}),I(this,u,{writable:!0,value:void 0}),d(this,"onAccountsChanged",e=>{e.length===0?this.emit("disconnect"):this.emit("change",{account:y(e[0])})}),d(this,"onChainChanged",async e=>{const a=Number(e),t=this.isChainUnsupported(a);await i(this,u).setItem(S,String(e)),this.emit("change",{chain:{id:a,unsupported:t}})}),d(this,"onDisconnect",async()=>{await o(this,g,C).call(this,[]),await i(this,u).removeItem(S),this.emit("disconnect")}),d(this,"onDisplayUri",e=>{this.emit("message",{type:"display_uri",data:e})}),d(this,"onConnect",()=>{this.emit("connect",{provider:i(this,n)})}),U(this,u,s.options.storage),o(this,P,b).call(this)}async connect(){var a;let{chainId:s,pairingTopic:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};try{let t=s;if(!t){const w=await i(this,u).getItem(S),l=w?parseInt(w):void 0;l&&!this.isChainUnsupported(l)?t=l:t=(a=this.chains[0])==null?void 0:a.chainId}if(!t)throw new Error("No chains found on connector.");const r=await this.getProvider();this.setupListeners();const p=await o(this,E,T).call(this);if(r.session&&p&&await r.disconnect(),!r.session||p){const w=[1,5,84531,137,80001,42161,421613,10,420,56,97,250,4002,43114,43113,1337].filter(l=>l!==t);this.emit("message",{type:"connecting"}),await r.connect({pairingTopic:e,chains:[t],optionalChains:w.length>0?w:[t]}),await o(this,g,C).call(this,this.chains.map(l=>{let{chainId:Q}=l;return Q}))}const f=await r.enable();if(f.length===0)throw new Error("No accounts found on provider.");const _=y(f[0]),m=await this.getChainId(),J=this.isChainUnsupported(m);return{account:_,chain:{id:m,unsupported:J},provider:new k(r)}}catch(t){throw/user rejected/i.test(t==null?void 0:t.message)?new L(t):t}}async disconnect(){const s=await this.getProvider();try{await s.disconnect()}catch(e){if(!/No matching key/i.test(e.message))throw e}finally{o(this,M,R).call(this),await o(this,g,C).call(this,[])}}async getAccount(){const{accounts:s}=await this.getProvider();if(s.length===0)throw new Error("No accounts found on provider.");return y(s[0])}async getChainId(){const{chainId:s}=await this.getProvider();return s}async getProvider(){let{chainId:s}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(i(this,n)||await o(this,P,b).call(this),s&&await this.switchChain(s),!i(this,n))throw new Error("No provider found.");return i(this,n)}async getSigner(){let{chainId:s}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const[e,a]=await Promise.all([this.getProvider({chainId:s}),this.getAccount()]);return new k(e,s).getSigner(a)}async isAuthorized(){try{const[s,e]=await Promise.all([this.getAccount(),this.getProvider()]),a=await o(this,E,T).call(this);if(!s)return!1;if(a&&e.session){try{await e.disconnect()}catch{}return!1}return!0}catch{return!1}}async switchChain(s){var a;const e=this.chains.find(t=>t.chainId===s);if(!e)throw new O(`Chain with ID: ${s}, not found on connector.`);try{const t=await this.getProvider(),r=o(this,D,V).call(this),p=o(this,W,G).call(this);if(!r.includes(s)&&p.includes(N)){const _=(a=e.explorers)!=null&&a.length?{blockExplorerUrls:[e.explorers[0].url]}:{};await t.request({method:N,params:[{chainId:q(e.chainId),chainName:e.name,nativeCurrency:e.nativeCurrency,rpcUrls:[...e.rpc],..._}]});const m=await o(this,A,F).call(this);m.push(s),await o(this,g,C).call(this,m)}return await t.request({method:"wallet_switchEthereumChain",params:[{chainId:q(s)}]}),e}catch(t){const r=typeof t=="string"?t:t==null?void 0:t.message;throw/user rejected request/i.test(r)?new L(t):new O(t)}}async setupListeners(){i(this,n)&&(o(this,M,R).call(this),i(this,n).on("accountsChanged",this.onAccountsChanged),i(this,n).on("chainChanged",this.onChainChanged),i(this,n).on("disconnect",this.onDisconnect),i(this,n).on("session_delete",this.onDisconnect),i(this,n).on("display_uri",this.onDisplayUri),i(this,n).on("connect",this.onConnect))}}async function b(){return i(this,v)||U(this,v,o(this,H,$).call(this)),i(this,v)}async function $(){const{default:h,OPTIONAL_EVENTS:s,OPTIONAL_METHODS:e}=await K(()=>import("./index.es-5ea0dcdb.js"),["assets/index.es-5ea0dcdb.js","assets/index-20076c51.js","assets/index-bdbd7312.css","assets/index-3a9e22cb.js","assets/index-cf75820f.js"]),[a,...t]=this.chains.map(r=>{let{chainId:p}=r;return p});a&&U(this,n,await h.init({showQrModal:this.options.qrcode!==!1,projectId:this.options.projectId,optionalMethods:e,optionalEvents:s,chains:[a],optionalChains:t,metadata:{name:this.options.dappMetadata.name,description:this.options.dappMetadata.description||"",url:this.options.dappMetadata.url,icons:[this.options.dappMetadata.logoUrl||""]},rpcMap:Object.fromEntries(this.chains.map(r=>[r.chainId,r.rpc[0]])),qrModalOptions:this.options.qrModalOptions}))}async function T(){if(o(this,W,G).call(this).includes(N)||!this.options.isNewChainsStale)return!1;const s=await o(this,A,F).call(this),e=this.chains.map(t=>{let{chainId:r}=t;return r}),a=o(this,D,V).call(this);return a.length&&!a.some(t=>e.includes(t))?!1:!e.every(t=>s.includes(t))}function R(){i(this,n)&&(i(this,n).removeListener("accountsChanged",this.onAccountsChanged),i(this,n).removeListener("chainChanged",this.onChainChanged),i(this,n).removeListener("disconnect",this.onDisconnect),i(this,n).removeListener("session_delete",this.onDisconnect),i(this,n).removeListener("display_uri",this.onDisplayUri),i(this,n).removeListener("connect",this.onConnect))}async function C(h){await i(this,u).setItem(x,JSON.stringify(h))}async function F(){const h=await i(this,u).getItem(x);return h?JSON.parse(h):[]}function V(){var s,e,a;return i(this,n)?((a=(e=(s=i(this,n).session)==null?void 0:s.namespaces[j])==null?void 0:e.chains)==null?void 0:a.map(t=>parseInt(t.split(":")[1]||"")))??[]:[]}function G(){var s,e;return i(this,n)?((e=(s=i(this,n).session)==null?void 0:s.namespaces[j])==null?void 0:e.methods)??[]:[]}export{Z as WalletConnectConnector};
